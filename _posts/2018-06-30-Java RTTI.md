---
layout:     post
title:     Java RTTI （上）
subtitle:  《Java编程思想》学习笔记 
date:       2018-06-30
author:    Lmx 
header-img: 
catalog: true
tags: 
    - 《Java编程思想》学习笔记 
---

# 概念
RTTI(Run-Time Type identification，运行时类型信息）: 使得程序可以在运行时，识别出类型信息.
- “传统”的RTTI：编译时，就已经知道所有的类型
- “反射”机制：在运行时发现和使用类的信息

# 1. 为啥需要RTTI
使用RTTI，可以查询某个基类引用所指向的对象的确切类型，然后，对特例进行处理。

# 2. Class对象
- 概念：类是程序的一部分，每个类都有一个Class对象。类在其第一次使用时，被加载到JVM中，“类加载器”(JVM实现的一部分)就会产生一个Class对象（保存在同名的.class文件中）。一旦某个类的Class对象被加载到内存中，它就用来创建类的所有的“常规”。
- 获取方法：
    - Class.forName(类的文本名):取得Class对象的引用，作用：如果类还没有被加载就加载它，在加载过程，类的static子句被执行。
    - Object.getClass()
    - 类字面常量:类名.class
- 方法：
    - getName()/getSImpleName()/getCannonicalName()
    - getSuperclass()
    - isInterface() 
    - newInstance():实现“虚拟构造器”的一种途径，在不知道类的确切类型时，可正确的创建类对象
## 2.1 类字面常量 
- 为了使用类而做的准备工作：
    1. 加载:类加载器创建Class对象
    2. 链接:为静态域分配存储空间
    3. 初始化：执行静态初始化；
        - 使用类字面常量不会引起静态域初始化，相反使用Class.forName()获取的Class对象会引起初始化；
        - 引用stact final类型的变量也不会引起初始化（因为在编译期间就已经获取到其值）,非final类的static会引起初始化。


## 2.2 泛化的Class引用
Class<? extends (基类)>

# 3. 类型转换
- 向上转型：编译器允许自由地向上转型的赋值操作，不需要任何显示的转型操作
- 向下转型：需要显示的进行转型

- instanceof：判断某个对象是否为某个类的对象
